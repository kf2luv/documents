# HTTP缓存技术



对于一段时间内频繁向服务器请求的资源，浏览器对其进行本地缓存，减少请求次数，减轻网络负担。

具体来说，**缓存在本地的是「请求-响应」这一对数据**。类似于哈希表的结构，key由请求的URL和部分请求头信息组成，value就是服务器响应（包括header和payload）。

这样一来，根据一定的「缓存策略」，就可以有条件的使用本地缓存数据，而不用重复地向服务器发起请求。



---



## 缓存策略



### 强制缓存



#### Expires

当浏览器第一次向服务器发起请求，服务器发回「设置了`Expires`」的响应。 `Expires`是一个绝对时间，超过表示资源过期。

下次浏览器使用相同URL访问同一个资源时，就会查找缓存，对比当前时间是否小于`Expires`，若是表示资源未过期，那么直接使用缓存中的数据；否则，重新请求服务器资源，更新`Expires`时间。

![image-20241204153929635](https://ckfs.oss-cn-beijing.aliyuncs.com/img/202412041539698.png)

`Expires`是一个GMT（格林尼治标准时间）绝对时间。

**缺陷：**

1. 使用客户端获取的GMT时间与服务器GMT时间作比较，如果客户端主动修改了系统时间，就会出现缓存命中的误差。

2. 其次，GMT时间是基于格林尼治天文台测算时间后，每隔一小时向全世界发放调时信息。观测本身存在的误差以及非实时的同步机制，都可能会导致出现缓存命中的误差。



#### Cache-Control

`Cache-Control`是HTTP/1.1中重要的缓存规则。它可以在HTTP**请求头和响应头**中使用，提供了多样化的配置参数。同时也可以适用于更广泛的复杂场景。

| 选项     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| no-store | 不使用缓存，每次都向服务器请求                               |
| no-cache | 不使用强制缓存，每次进行响应前都向服务器进行缓存有效性验证（协商缓存） |
| max-age  | 客户端缓存的最长时间（相对时间），单位为秒。判断优先级高于`Expires`。 |

当浏览器第一次向服务器发起请求，服务器返回「设置了`Cache-Control: max-age`」的响应。`max-age`是一个相对时间，表示当前资源可以在客户端中保存多久。

下次浏览器使用相同URL访问同一个资源时，就会查找缓存，判断资源缓存的时间是否小于`max-age`，小于则直接使用缓存中的数据；否则，重新请求服务器资源，更新缓存时间。



---



### 协商缓存

如果强制缓存失效（Cache-Control: no-cache），那么就是协商缓存了。

协商缓存：客户端向服务器请求资源时，对服务器进行本地缓存有效性的判断（client问server：“我这里的缓存还能用不？”）。客户端通过判断结果，决定是否使用本地缓存。



协商缓存可以基于两种header实现：

1. 请求头部的`If-Modified-Since`和响应头部的`Last-Modified`，它们都是GMT时间（HTTP/1.0）

   - 客户端第一次发送请求后，服务器返回「设置了`Last-Modified`」（表示资源的最后修改时间）的响应，客户端将数据存入缓存；

   - 当客户端再次发送请求，就把请求头部的`If-Modified-Since`设置为之前服务器返回的响应头部的`Last-Modified`(client问server："自从上次修改后，有没有再修改过？")；

   - 服务器收到请求后，会对请求头中的`If-Modified-Since`和本地资源的`Last-Modified`进行比较，得出协商结果：

     若`If-Modified-Since` < `Last-Modified`，服务器资源被修改过，与客户端缓存不同，返回新资源，同时设置新的 `Last-Modified`；否则，资源没有被修改，告知客户端资源有效，返回304（Not Modified）

   

   > `Last-Modified`的缺陷：
   >
   > 1. 只关注时间，不关注文件内容。如果文件在被修改后又被恢复原状了，其实客户端还是可以使用缓存的，但是此时服务器就会更新`Last-Modified`，客户端协商缓存得到的结果是”资源无效“，又要白费力气去请求服务器资源。
   > 2. `Last-Modified`只监听到「秒级」的文件修改，若服务端一秒内对文件进行多次修改，客户端是不知道的，因为服务端返回的`Last-Modified`是不变的（同一秒内）。因此会导致客户端无法几乎更新缓存。

   

2. 请求头部的` If-None-Match`和响应头部的`ETag`（HTTP/1.1）

   ETag：服务器资源响应的标识符，由服务器通过某种算法对文件内容进行处理，得出的一个字符串，通常是使用内容的散列或简单的使用版本号。

   - 客户端第一次发送请求后，服务器返回「设置了`ETag`标识符」的响应，客户端将数据存入缓存；
   - 当客户端再次发送请求，就把请求头部的`If-None-Match`设置为之前服务器返回的响应头部的`ETag`(client问server："是否不匹配？")，与第一种方法的目的是一样的，都是为了确定资源是否有效，而这里不取决于时间，而是**取决于资源的内容**。
   - 服务器收到请求后，会对请求头中的`If-None-Match`和本地资源的`ETag`进行比较，查看本地资源的`ETag`是否与请求头中的`If-None-Match`匹配，得出协商结果：



参考文章：

[HTTP缓存看这一篇就够了]: https://www.51cto.com/article/746168.html

